# 真正的系统重启功能说明

## 功能描述

点击"加载制冷测试"或"加载制热测试"时，系统会**真正重启**，完全等同于重新运行程序。

## 实现原理

### 之前的方案（清除状态）
```python
# 只是清空了队列、计时器等
self.served_queue._rooms.clear()  # 清空列表
self.detail_record.clear_all_records()  # 清空数据库
```
**问题**：虽然清空了数据，但对象本身还是旧的，可能有隐藏的状态残留

### 现在的方案（重新创建对象）
```python
# 完全重新创建所有对象
self.rooms = RoomRepository(self._room_count)  # 新对象！
self.detail_record = DetailRecord()  # 新对象！
self.scheduler = Scheduler(...)  # 新对象！
```
**效果**：所有对象都是全新的，完全等同于重新运行程序！

## 重新创建的对象

| 对象 | 说明 | 内部包含 |
|------|------|----------|
| `RoomRepository` | 房间仓库 | 5个全新的Room对象 |
| `Room` | 房间对象 | 状态、温度、费用、模式等 |
| `DetailRecord` | 详单记录 | 数据库连接（清空所有记录） |
| `Scheduler` | 调度器 | 队列、计时器、Server等 |
| `ServedQueue` | 服务队列 | 全新的空队列 |
| `WaitingQueue` | 等待队列 | 全新的空队列 |
| `ServiceTimer` | 服务计时器 | 全新的空字典 |
| `WaitTimer` | 等待计时器 | 全新的空字典 |
| `Server` | 服务对象 | 全新的温控逻辑 |

## 代码实现

### HotelACSystem.__init__()

```python
def __init__(self, room_count: int, served_capacity: int, 
             waiting_capacity: int, time_slice_seconds: int):
    # 保存初始化参数，用于重启时重新创建对象
    self._room_count = room_count
    self._served_capacity = served_capacity
    self._waiting_capacity = waiting_capacity
    self._time_slice_seconds = time_slice_seconds
    
    # 初始化系统组件
    self._initialize_system()
```

### _initialize_system()（内部方法）

```python
def _initialize_system(self):
    """内部方法：初始化系统所有组件"""
    # 创建全新的 RoomRepository - 所有房间对象重新创建
    self.rooms = RoomRepository(self._room_count)
    
    # 创建全新的 DetailRecord - 清空数据库
    self.detail_record = DetailRecord()
    self.detail_record.clear_all_records()  # 清空数据库中的所有记录
    
    # 创建全新的 Scheduler - 所有队列、计时器重新创建
    self.scheduler = Scheduler(
        rooms=self.rooms,
        served_capacity=self._served_capacity,
        waiting_capacity=self._waiting_capacity,
        time_slice_seconds=self._time_slice_seconds,
        detail_record=self.detail_record,
    )
```

### reset_system()（公开方法）

```python
def reset_system(self):
    """
    完全重启系统 - 等同于重新运行程序
    重新创建所有对象：RoomRepository、DetailRecord、Scheduler、队列、计时器等
    """
    print("✓ 正在重启系统（等同于重新运行程序）...")
    
    # 重新初始化整个系统 - 所有对象重新创建
    self._initialize_system()
    
    print("✓ 系统重启完成！所有对象已重新创建")
```

## 使用效果

### 场景：连续运行制热和制冷

```bash
# 程序启动
程序运行 → 创建 HotelACSystem 对象
  ↓
创建 RoomRepository（5个Room对象）
创建 DetailRecord（数据库连接）
创建 Scheduler（队列、计时器、Server）

# 第一次测试
点击"制热测试" → system.reset_system()
  ↓
重新创建 RoomRepository（全新的5个Room对象）
重新创建 DetailRecord（清空数据库）
重新创建 Scheduler（全新的队列、计时器）
  ↓
运行制热测试 ✓

# 第二次测试
点击"制冷测试" → system.reset_system()
  ↓
再次重新创建 RoomRepository（又是全新的5个Room对象）
再次重新创建 DetailRecord（再次清空数据库）
再次重新创建 Scheduler（又是全新的队列、计时器）
  ↓
运行制冷测试 ✓（完全不受制热影响）
```

## 等同于重新运行程序

### 原来的程序启动

```bash
$ python backend_app.py
→ 创建 HotelACSystem
  → 创建 RoomRepository
  → 创建 DetailRecord
  → 创建 Scheduler
```

### 现在点击"加载测试用例"

```bash
点击"制冷测试"按钮
→ system.reset_system()
  → 重新创建 RoomRepository  # 就像重新运行程序
  → 重新创建 DetailRecord    # 就像重新运行程序
  → 重新创建 Scheduler       # 就像重新运行程序
```

**完全一样的效果！**

## 对比：清除 vs 重新创建

### 方案1：清除状态（旧方案）

```python
# 清空队列
self.served_queue._rooms.clear()  # 清空列表，但对象还是旧的

# 清空房间状态
for room in rooms:
    room.state = OFF
    room.cost = 0.0
    # 但 room 对象本身还是旧的，可能有隐藏状态
```

**风险**：可能有未知的状态残留

### 方案2：重新创建对象（新方案）

```python
# 创建全新的队列对象
self.served_queue = ServedQueue(capacity)  # 全新对象！

# 创建全新的房间对象
self.rooms = RoomRepository(count)  # 所有房间都是新的！
```

**优势**：完全没有状态残留，就像重新运行程序

## 控制台输出

```
========== 开始加载制冷测试用例 ==========
正在重置系统状态...
✓ 正在重启系统（等同于重新运行程序）...
✓ 系统重启完成！所有对象已重新创建
```

## 内存对比

### 重启前
```
内存中的对象：
- RoomRepository@0x1234 
  - Room(id=1)@0x5678
  - Room(id=2)@0x9ABC
- Scheduler@0xDEF0
  - ServedQueue@0x1111
  - WaitingQueue@0x2222
```

### 重启后
```
内存中的对象（全新！）：
- RoomRepository@0xAAAA  # 新地址！
  - Room(id=1)@0xBBBB    # 新地址！
  - Room(id=2)@0xCCCC    # 新地址！
- Scheduler@0xDDDD       # 新地址！
  - ServedQueue@0xEEEE   # 新地址！
  - WaitingQueue@0xFFFF  # 新地址！
```

**所有对象都是全新创建的！**

## 修改的文件

1. `ac_core/scheduler.py`
   - 添加 `_initialize_system()` 内部方法
   - 修改 `__init__()` 保存初始化参数
   - 修改 `reset_system()` 调用 `_initialize_system()`
   - 删除 `reset_test_state()` 方法（不再需要）

2. `hotel/hotel/ac_core/scheduler.py` - 同步更新

## 优势

✅ **完全等同于重新运行程序**
✅ **没有任何状态残留**
✅ **所有对象都是全新的**
✅ **彻底解决制热后制冷出错的问题**
✅ **简单可靠，易于理解**

## 更新日期
2025年

## 相关文档
- [更新说明.md](./更新说明.md) - 系统功能更新
- [温度范围说明.md](./温度范围说明.md) - 温度范围限制

