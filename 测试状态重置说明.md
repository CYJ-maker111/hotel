# 测试状态重置说明（修订版）

## 问题重新分析

用户反馈：
- ❌ 不希望每次更换测试用例就清除累计费用
- ✅ 但需要修复"跑完制热后跑制冷会出错"的bug

## 真正的问题

跑完制热再跑制冷出错的原因**不是累计费用**，而是：

1. **队列状态遗留** - 上次测试的房间还在队列中
2. **计时器遗留** - 服务时间、等待时间没有清零
3. **房间运行状态遗留** - 房间状态(SERVING/WAITING/PAUSED)没有重置为OFF
4. **累计秒数遗留** - 影响温度四舍五入逻辑

这些状态影响了新测试的调度逻辑，但**累计费用和详单记录不影响**！

## 解决方案（修订）

### 重置内容

只重置影响测试运行的状态：

✅ **需要重置**：
- 服务队列（served_queue）
- 等待队列（waiting_queue）
- 服务计时器（service_timer）
- 等待计时器（wait_timer）
- 累计秒数（_accumulated_seconds）
- 分钟开始温度（_minute_start_temps）
- 详单记录ID映射（current_record_ids）
- 房间运行状态（state → OFF）
- 房间服务统计（total_served_seconds、total_waiting_seconds）

❌ **保留不变**：
- ✅ 累计费用（room.cost）
- ✅ 详单记录（detail_records 表）
- ✅ 房间初始温度（initial_temp）
- ✅ 房间当前温度（current_temp）

### 修改后的代码

#### 1. Scheduler.reset_test_state()（重命名）

```python
def reset_test_state(self):
    """
    重置测试相关的运行状态，但保留累计费用和详单记录
    用于加载新测试用例时清除影响测试的状态，但保留账单数据
    """
    # 1. 清空服务队列和等待队列
    self.served_queue._rooms.clear()
    self.waiting_queue._rooms.clear()
    
    # 2. 清空计时器
    self.service_timer._served_seconds.clear()
    self.wait_timer._waiting_seconds.clear()
    
    # 3. 重置累计秒数和分钟开始温度
    self._accumulated_seconds = 0
    self._minute_start_temps.clear()
    
    # 4. 清除当前详单记录ID映射（但不清除详单记录本身）
    self.current_record_ids.clear()
    
    # 5. 重置所有房间的运行状态为关机，但保留累计费用
    for room_id in self.rooms.rooms.keys():
        room = self.rooms.get(room_id)
        room.state = PowerState.OFF  # 重置为关机状态
        # 保留 room.cost - 不清除累计费用！
        room.total_served_seconds = 0
        room.total_waiting_seconds = 0
```

#### 2. HotelACSystem.reset_system()

```python
def reset_system(self):
    """
    重置系统的运行状态，用于加载新的测试用例
    清除：队列、计时器、房间运行状态、累计秒数等
    保留：累计费用、详单记录（用于账单统计）
    """
    # 重置调度器的测试状态
    self.scheduler.reset_test_state()
    
    # 不清除详单记录 - 保留累计费用用于账单
    # self.detail_record.clear_all_records()  # 注释掉
    
    print("✓ 系统测试状态已重置（保留累计费用）")
```

## 为什么这样可以解决问题

### 问题场景分析

**制热测试结束后的状态**：
```
房间1: state=OFF, mode=HEAT, cost=100元
服务队列: [1, 2, 3]  ← 问题！
等待队列: [4, 5]     ← 问题！
服务计时器: {1: 300秒, 2: 250秒, 3: 200秒}  ← 问题！
```

**开始制冷测试**：
```
问题1: 队列中还有上次的房间，影响调度逻辑
问题2: 计时器保留上次的时间，影响时间片调度
问题3: 累计秒数不为0，影响温度四舍五入
```

**重置后**：
```
房间1: state=OFF, mode=HEAT, cost=100元  ← 保留！
服务队列: []         ← 清空 ✓
等待队列: []         ← 清空 ✓
服务计时器: {}       ← 清空 ✓
累计秒数: 0          ← 重置 ✓
```

现在制冷测试可以正常运行，且累计费用保留！

## 使用效果

### 场景1：连续运行不同模式测试

```bash
1. 运行制热测试
   - 房间1: 累计费用 100元
   - 房间2: 累计费用 80元

2. 加载制冷测试 → 重置测试状态
   - 队列清空 ✓
   - 计时器清空 ✓
   - 房间状态OFF ✓
   - 累计费用保留 ✓（房间1: 100元，房间2: 80元）

3. 运行制冷测试
   - 正常运行 ✓
   - 继续累计费用（房间1: 100 + 新费用，房间2: 80 + 新费用）
```

### 场景2：查看累计账单

```bash
1. 运行制热测试
2. 运行制冷测试
3. 查看房间账单 → 显示制热+制冷的总费用 ✓
4. 导出Excel → 包含制热和制冷的所有详单记录 ✓
```

## 控制台输出

加载测试用例时会看到：

```
========== 开始加载制冷测试用例 ==========
正在重置系统状态...
✓ 系统测试状态已重置（保留累计费用）
```

## 对比：修改前后

| 项目 | 修改前 | 修改后 |
|------|--------|--------|
| 累计费用 | ❌ 清除 | ✅ 保留 |
| 详单记录 | ❌ 清除 | ✅ 保留 |
| 服务队列 | ✅ 清除 | ✅ 清除 |
| 计时器 | ✅ 清除 | ✅ 清除 |
| 房间状态 | ✅ 重置OFF | ✅ 重置OFF |
| 累计秒数 | ✅ 重置0 | ✅ 重置0 |

## 修改的文件

1. `ac_core/scheduler.py`
   - `reset_system_state()` → `reset_test_state()`（重命名）
   - 不清除 `room.cost`
   - `reset_system()` 不调用 `clear_all_records()`

2. `hotel/hotel/ac_core/scheduler.py` - 同步更新

## 更新日期
2025年

## 相关文档
- [系统重置功能说明.md](./系统重置功能说明.md) - 原版本（已过时）
- [更新说明.md](./更新说明.md) - 系统功能更新

